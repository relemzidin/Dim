<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Floating Arrows</title>
    <style>
        /* --- Basic Setup & Dark Theme --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
            font-family: sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #121212; /* Slightly darker background */
            color: #e0e0e0;
        }

        /* --- 3D Scene Setup --- */
        .scene {
            width: 80vmin; /* Use viewport units for better scaling */
            height: 80vmin;
            max-width: 400px;
            max-height: 400px;
            perspective: 1200px; /* Increased perspective for more depth */
            perspective-origin: 50% 50%;
            margin-bottom: 30px;
        }

        .arrow-cluster {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transform: translateZ(-50px);
            animation: floatRotate 35s linear infinite alternate; /* Slower, smoother rotation */
        }

        /* --- 3D Arrow Styling --- */
        :root {
             /* Define arrow dimensions as CSS variables */
            --arrow-length: 60px;
            --arrow-thickness: 5px; /* Thickness and depth of the shaft */
            --head-size: 10px; /* Size of the base of the arrowhead */
            --head-length: 14px; /* Length of the arrowhead */
        }

        .arrow {
            position: absolute;
            /* Position the arrow's logical origin at the center */
            top: 50%;
            left: 50%;
            /* Set width/height conceptually, but faces define visual size */
            width: var(--arrow-thickness);
            height: var(--arrow-length);
            transform-style: preserve-3d;
            /* Rotate around the base (top-center in 2D projection) */
            /* For 3D, origin is (width/2, 0, depth/2) */
             transform-origin: calc(var(--arrow-thickness) / 2) 0 calc(var(--arrow-thickness) / 2);
            /* Initial transform set by JS */
        }

        /* Shaft Faces */
        .shaft-face {
            position: absolute;
            width: var(--arrow-thickness);
            height: var(--arrow-length);
            background-color: var(--arrow-color, #ff0000);
            /* Center faces horizontally relative to the .arrow container's origin */
            left: 0;
            top: 0;
             /* Improve 3D look with subtle shading */
             filter: brightness(90%);
        }

        .shaft-front {
            transform: translateZ(calc(var(--arrow-thickness) / 2));
             filter: brightness(100%); /* Front face brightest */
        }

        .shaft-back {
            transform: rotateY(180deg) translateZ(calc(var(--arrow-thickness) / 2));
             filter: brightness(70%); /* Back face darkest */
        }

        .shaft-left {
            width: var(--arrow-thickness); /* Depth = Thickness */
            transform: rotateY(-90deg) translateZ(calc(var(--arrow-thickness) / 2));
             filter: brightness(85%);
        }

        .shaft-right {
            width: var(--arrow-thickness); /* Depth = Thickness */
            transform: rotateY(90deg) translateZ(calc(var(--arrow-thickness) / 2));
            filter: brightness(85%);
        }

         /* Simple 2D Arrowhead using ::after */
        .arrow::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            /* Position arrowhead at the tip (bottom) of the shaft */
            /* It needs to be positioned relative to the *center* of the shaft end */
            top: var(--arrow-length); /* Position below the shaft */
            left: calc(var(--arrow-thickness) / 2); /* Center horizontally */
            transform: translateX(-50%); /* Center the arrowhead base */

            /* Triangle shape */
            border-left: var(--head-size) solid transparent;
            border-right: var(--head-size) solid transparent;
            border-top: var(--head-length) solid var(--arrow-color, #ff0000); /* Pointing "down" */

            /* Bring the 2D head slightly forward to avoid z-fighting with shaft faces */
            /* Adjust this value if the head looks detached or hidden */
            transform: translateX(-50%) translateZ(calc(var(--arrow-thickness) / 2 + 1px));
            filter: brightness(100%);
        }


        /* --- Animation --- */
        @keyframes floatRotate {
            0% {
                transform: translateZ(-50px) rotateX(0deg) rotateY(0deg) rotateZ(0deg);
            }
            100% {
                 /* Alternate makes it float back and forth */
                transform: translateZ(-50px) rotateX(360deg) rotateY(-360deg) rotateZ(180deg);
            }
        }

        /* --- Controls Styling --- */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 20px;
            background-color: rgba(42, 42, 42, 0.8); /* Semi-transparent background */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px); /* Optional: Frosted glass effect */
            -webkit-backdrop-filter: blur(5px);
        }

        .controls label {
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .controls input[type="range"] {
            width: 200px;
            cursor: pointer;
        }

        #arrowCountSpan {
            font-weight: bold;
            min-width: 30px; /* Wider span */
            text-align: center;
            display: inline-block;
            background-color: rgba(0,0,0,0.3);
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
        }

    </style>
</head>
<body>

    <div class="scene">
        <div class="arrow-cluster" id="arrowCluster">
            <!-- Arrows will be generated here by JS -->
        </div>
    </div>

    <div class="controls">
        <label for="numArrowsSlider">
            Number of Arrows: <span id="arrowCountSpan">30</span>
        </label>
        <input type="range" id="numArrowsSlider" min="1" max="100" value="30"> <!-- Reduced max for performance -->
    </div>

    <script>
        const arrowCluster = document.getElementById('arrowCluster');
        const numArrowsSlider = document.getElementById('numArrowsSlider');
        const arrowCountSpan = document.getElementById('arrowCountSpan');

        function createArrow(index, total) {
            const arrow = document.createElement('div');
            arrow.classList.add('arrow');

            // Generate a distinct color using HSL
            const hue = (index / total) * 360;
            const color = `hsl(${hue}, 85%, 65%)`; // Slightly adjusted saturation/lightness
            arrow.style.setProperty('--arrow-color', color);

            // --- Create Shaft Faces ---
            const faces = ['front', 'back', 'left', 'right'];
            faces.forEach(faceType => {
                const face = document.createElement('div');
                face.classList.add('shaft-face', `shaft-${faceType}`);
                arrow.appendChild(face);
            });

            // --- Calculate Initial 3D Orientation ---
            // Using random rotations is simple but can cluster.
            // Fibonacci sphere distribution (more complex) gives better spacing.
            // For simplicity, we stick to random for now.
            const randomRotX = Math.random() * 360;
            const randomRotY = Math.random() * 360;
            const randomRotZ = Math.random() * 360;

            // Apply initial transform to position and orient the arrow
            // translate3d centers the arrow's origin point (base center)
            // Then apply the random rotations
            arrow.style.transform = `
                translate3d(-50%, -50%, 0) /* Center origin in cluster */
                rotateX(${randomRotX}deg)
                rotateY(${randomRotY}deg)
                rotateZ(${randomRotZ}deg)
            `;

            arrowCluster.appendChild(arrow);
        }

        function updateArrows(count) {
            // Clear existing arrows
            arrowCluster.innerHTML = '';

            // Update count display
            arrowCountSpan.textContent = count;

            // Create new arrows
            for (let i = 0; i < count; i++) {
                createArrow(i, count);
            }
        }

        // Event listener for the slider
        numArrowsSlider.addEventListener('input', (event) => {
            const count = parseInt(event.target.value, 10);
            // Use requestAnimationFrame to prevent blocking UI thread during updates
            window.requestAnimationFrame(() => updateArrows(count));
        });

        // Initial setup on page load
        updateArrows(parseInt(numArrowsSlider.value, 10));

    </script>

</body>
</html>